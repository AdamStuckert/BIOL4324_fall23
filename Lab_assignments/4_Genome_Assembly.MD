## Genome assembly

Today we will be using public data to assemble and assess the genome of the fruit fly *Drosophila ananassae*. These data come from [Tvedte et al. 2021](https://academic.oup.com/g3journal/article/11/6/jkab083/6188627?login=true#304735456). Please note that I have already downloaded these raw data for you, and additionally I have subsampled the data down substantially so that we will be able to run these assemblies in a short timeframe with limited resources. As a result of this, you should not expect to get particularly amazing genome assemblies!

As an aside, I suggest creating a new directory for every lab we do (e.g., something called "lab4" or "genome_assembly") so that you don't have a bajillion files in your home directory. That can get reaaaaaaally confusing, reallllllly quickly.


## Software installs

Wahoo! Today is the first day y'all will deal with software installs. Welcome to hell.


```bash
/project/stuckert/apps/Anaconda3-2023.07-2/condabin/conda init
```

At this point you should see results that look something like this:

```
[astucker@opuntia condabin]$ ./conda init
no change     /project/stuckert/apps/Anaconda3-2023.07-2/condabin/conda
no change     /project/stuckert/apps/Anaconda3-2023.07-2/bin/conda
no change     /project/stuckert/apps/Anaconda3-2023.07-2/bin/conda-env
no change     /project/stuckert/apps/Anaconda3-2023.07-2/bin/activate
no change     /project/stuckert/apps/Anaconda3-2023.07-2/bin/deactivate
no change     /project/stuckert/apps/Anaconda3-2023.07-2/etc/profile.d/conda.sh
no change     /project/stuckert/apps/Anaconda3-2023.07-2/etc/fish/conf.d/conda.fish
no change     /project/stuckert/apps/Anaconda3-2023.07-2/shell/condabin/Conda.psm1
no change     /project/stuckert/apps/Anaconda3-2023.07-2/shell/condabin/conda-hook.ps1
no change     /project/stuckert/apps/Anaconda3-2023.07-2/lib/python3.11/site-packages/xontrib/conda.xsh
no change     /project/stuckert/apps/Anaconda3-2023.07-2/etc/profile.d/conda.csh
modified      /project/stuckert/astucker/.bashrc

==> For changes to take effect, close and re-open your current shell. <==
```

This has updated our `bashrc` file for us. This is a "hidden" file that lives in our home directory that includes stored information about our setup, you can think of it as analogous to a user profile. Things found in here are functions, aliases, and critically, our `$PATH`. In order for changes to our bashrc to take effect we either need to close and reopen our shell session, or just source our `bashrc` files. Lets do the latter.

```
source ~/.bashrc
```

The changes to our bashrc should now have taken effect.

**Question 1:** Print your path to screen and paste in what is in your path.


Now we'll make a "conda environment" that will hold all of our installations, activate it, and install the programs we'll need for today's lab. Software installs are annoying. And often you end up with conflicting installs to run different tasks/pieces of software. So people have develope software management systems, things like anaconda, docker, and singularity which create environments or packages with which to install and run software without interfering with other software. These are really useful, particularly if you need versions of python 2 and python 3, for example.

The maintainers of the UH Carya cluster have already installed anaconda for us. We can create "environments" which are self-contained units of software. You can think of it like a shipping container on a big ship making a transatlantic crossing with goods (this is why one software management program is called "docker", because it ships containers). The only caveat is that we need to create environments and place them somewhere we have read/write permissions.

```bash
conda create --prefix Absolute/path/ofa/directory/in/your/file/structure/ENV_NAME
```




Sub out the path + ENV_NAME for your path and a reasonable environment name. You might choose to go with `genome_assembly` or similar. It will ask you if you are sure you want to modify this, yadda yadda, and the answer is yes. You can then load that environment with `conda activate Absolute/path/ofa/directory/in/your/file/structure/ENV_NAME`. This is analogous to stepping inside the shipping container. 

Narrator's note: writing all of that path every time you want to do something is probably annoying. You might consider using a variable.....

**Question 2:** What code would you use to set that path as a variable?
**Question 3:**  How would you use that variable in the above `conda activate` code?

You can "exit" the environment by using `conda deactivate`.

**Question 4:** Activate and deactivate the environment a couple of times. What changes about your prompt when you activate the conda environment?

Now, install some software. This may take a while...but luckily for you I tested which software packages take forever/are difficult to install and I made this easier/less time consuming for you so you don't spend the whole lab installing software.

```bash
conda activate ENV_NAME  
conda install -y -c bioconda -c conda-forge compleasm
```

Install `SPades`. This is an assembler for a variety of things, including Illumina data of small genomes.

```bash
wget http://cab.spbu.ru/files/release3.15.5/SPAdes-3.15.5-Linux.tar.gz
tar -xzf SPAdes-3.15.5-Linux.tar.gz # the downloaded file is a "tarball" which you have to extract (like a zipped folder)
cd SPAdes-3.15.5-Linux/bin/ # this is the directory your program lives in.
```

Test this install out immediately! Run `./spades.py`. If you get the help message from SPades then your install isn't immediately obviously broken. You can and SHOULD test software installs before using them on real data. Software often comes with toy datasets to use. For today, we will "test" it with our small datasets.

Install `Hifiasm`. This program is developed to assemble genomes from accurate long read data. Follow the installation instructions on the [Hifiasm GitHub page](https://github.com/chhylp123/hifiasm).

Test this install out immediately! Run `hifiasm`.

**Question 5:** Did your SPades and Hifiasm installs work?

If your installs worked, we are now ready to proceed to the analyses/genome assemblies.

### A quick word about "arguments"  

An argument is a piece of information that you give a program you want to run. This can be almost anything - a parameter it needs to know to get the analysis right, an input or output file, the path to a database the program will need, etc. These arguments can be denoted in two different ways. They can be **named** and have a "flag" associated with them: `-i` for the input file, for example. Or they can be **positional** which means that the program knows what you want it to do with that information based on the order that you give. For example, in the command `grep ">" sequence.fasta`, grep knows that `">"` is the thing you want to search for, and `sequence.fasta` is the thing you want to search inside based on the order that you gave it those pieces of information.  

Another thing to know about named arguments in particular is that sometimes there will be a flag that needs something to come after it, and sometimes it is fine on it's own. For example, if `-i` stands for input file (or input directory), then you should give it a file or directory name after the flag (separated by a space). If the flag is something like `-v` in grep (that searches for the inverse of what you specify), then it functions more as a switch that you can turn on or off so that the program will behave in one way or another. The only way to know for sure is to check the manual (which for many programs, can be found online, or by typing the name of the command followed by `--help`).  

Try to watch for these as you go through this lab. It will help you start to know how to put commands together on your own.  
  
  
Now make sure you are in your home directory and we'll get into the actual lab.


## Lab 4 - Genome Assembly - the meat and potatoes

As mentioned above, today in lab we are going to be assembling a fruit fly (*Drosophila ananassae*) in two different ways. First, with Illumina reads and then using PacBio HiFi reads (highly accurate long reads).

We will then evaluate each genome assembly using `assemblathon_stats.pl` to assess contiguity and `compleasm` to assess genic content. We will use the outputs from these programs to compare the two assemblies.

### Assembling the Illumina reads  
  
This program was developed in part by the Russian man whose De Bruijn graph videos we've been watching in class. His name is Pavel Pevzner.  
This command will take a little while to run, so be patient. It will give you updates as it is running, and you should see if you understand some of the messages it will print to the screen.  
Here is the SPAdes github page, if you're interested in more of the options: https://github.com/ablab/spades#sec2 
- The options you see with `-pe` or `-mp` at the beginning refer to "paired end" or "mate pair" data, like we talked about in class.
- The `-m` is a memory limit for when SPAdes is running. This will depend on what size computer you are running the program.

**Question 4:** Can you guess what information `-k` gives this program? You can check the github page above to see if you are right.

- The `-o` option is specifying the output, as usual, but this time it is an output directory, so make sure you name it accordingly (and don't include a file extension).  

**Remember, you must run tasks on the compute node, not the login node. Please do not run any assemblies on the head/login node!**

**Question ** What is the header you are using in your script to tell SLURM what resources it needs?


The data for this assembly are here: `/project/stuckert/bioinformatics/lab4`. These are the files with `Illumina` in the file name. Remember, Illumina data is _usually paired end_ so there are two sets of reads, a forward and reverse. 

spades.py -t 5 -m 55 --mp1-rf -k 95  --pe1-1 FORWARD_READS  --pe1-2 REVERSE_READS  -o illumina_assembly
  
  
#### Evaluating our short read assembly  

```bash
minibusco run --assembly_path $ASSEMBLY \
--output_dir $BUSCO_OUT --threads 5 --lineage $LINEAGE \
--library_path /project/stuckert/minibusco_downloads
```
Assess the genome length/contiguity:
```bash
/project/stuckert/software/assemblathon_stats.pl GENOMEEEEEE
```


### Assembling the PacBio reads

This program uses what it called a "fuzzy" De Bruijn graph to make it's assemblies. You can read about it here: https://github.com/ruanjue/wtdbg2  

There are two steps, one for the actual assembly and one for making the final consensus sequence. Neither take very long! Make sure you are paying attention to your output and input files for these programs.  

Assembler:  
The first part of this is the relative path to the command we are going to run (you could also give it an absolute path here and it would work great).  
Next there are some options to choose and parameters to set.   
- The `-x rs` is specifying the sequencing tech that was used to produce the reads - this is the code for PacBio (but there are others on the website above).
- **Question 2:** Head to the website above (that github site) and find where it tells you what some of the options are for running this command. What does the `-g 4.6m` mean in this command?
- The `-t 5` is the number of "threads" we are using for this command. It's sort of the number of simultaneous processes we want going at the same time, but be careful! More is not always better! It will depend on the type of computer you are working on.
- The `-i` is where the input file goes, which in this case is our PacBio reads that we downloaded.
- Finally the `-fo` is where you put the prefix of the output file name you want. Remember last week when we made the blast database and we just gave it the first part of the filename, and then it created three different files that all had different file extensions? This will be exactly like that. The "f" part means that it will force the program to overwrite any files that already have that name, which is great if you end up needing to run it multiple times, but less great if something is already named that - be careful!
> ./wtdbg2/wtdbg2 -x rs -g 4.6m -t 5 -i pacbio.fastq -fo long
  
  
Consenser (this is their word, it's a new one for me):  
You'll notice that the path is the same, but the name of the command is different for this one.  
**Question 3:** list off the different parts of this command and say what information they give the program.  
> ./wtdbg2/wtpoa-cns -t 5 -i long.ctg.lay.gz -fo long.ctg.fa

#### Evaluating our long read assembly  

Now we can evaluate the genome assembly we just made in two different ways. **Important:** The output file from your last command (above) is going to be the input file of both of these two programs.  

Run quast on the finished assembly.  
- The first piece of information that you give the command `quast` is the input file name (so, the name of your finished assembly). It does not have an `-i` in front of it, but it is still the same thing. Different programs just do things differently.  
- The `-R` here is the *E. coli* reference genome, which you downloaded earlier with the two datasets.  
- The `-o` should be pretty familiar to you by now - it is our output directory, where Quast will put all of the output files it makes.  
- We are also giving it a number of threads to run on, and a `--gene-finding` option so that we can get some extra information in the output files.  
> quast long.ctg.fa -R GCF_000005845.2_ASM584v2_genomic.fna.gz -o long_reads_output --threads 24 --gene-finding
  

**REPLACE WITH MINIBUSCO**
Run BUSCO on the finished assembly.  
- In this command, `-m` is the "mode" that we are running BUSCO in. You could also have chosen "protein" or "transcriptome" if they were more appropriate.  
- The `-i` and `-o` are input file and output directory, as usual.  
- The `-l` is the database we want BUSCO to use. In this case, we want the bacterial one. It will download automatically when BUSCO starts to run.  
> busco -m genome -i long.ctg.fa -o busco_long -l bacteria_odb10


### Assembling the Illumina reads  
  
This program was developed in part by the Russian man whose De Bruijn graph videos we've been watching in class. His name is Pavel Pevzner.  
This command will take a little longer to run, so be patient. It will give you updates as it is running, and you should see if you understand some of the messages it will print to the screen.  
Here is the SPAdes github page, if you're interested in more of the options: https://github.com/ablab/spades#sec3.2  
- The options you see with `-pe` or `-mp` at the beginning refer to "paired end" or "mate pair" data, like we talked about in class.
- The `-m` is a memory limit for when SPAdes is running. This will depend on what size computer you are running the program.
- **Question 4:** Can you guess what information `-k` gives this program? You can check the github page above to see if you are right.
- The `-o` option is specifying the output, as usual, but this time it is an output directory, so make sure you name it accordingly (and don't include a file extension).  
> spades.py -t 24 -m 55 --mp1-rf -k 95  --pe1-1 ecoli_pe.1.fq  --pe1-2 ecoli_pe.2.fq  --mp1-1 nextera.1.fq  --mp1-2 nextera.2.fq  -o short_assembly
  
  
#### Evaluating our short read assembly  

```bash
minibusco run --assembly_path $ASSEMBLY \
--output_dir $BUSCO_OUT --threads 5 --lineage $LINEAGE \
--library_path /project/stuckert/minibusco_downloads
```

**Question 5:** Run Quast on the finished SPAdes assembly. The input file for this will be inside the output directory name you gave to SPAdes in the last command. It will always be called "scaffolds.fasta". Change the input and output file names, but make everything else identical to the quast command you ran for the PacBio assembly. Paste in the command you used to run this.  

**Question 6:** Run BUSCO on the finished SPAdes assembly. Again, you should only have to change the input and output files, and make everything else just like it was for the PacBio assembly above. Paste in your command.  


### Comparing the two assemblies  

We will use a file from each of our evaluation commands to compare these two assemblies. For Quast, the file we want is called "report.txt" and it is inside the output directory you specified. For BUSCO, the file name is long, but begins with "short_summary" and is inside the output directory that BUSCO made using the name that you gave it.  

**Question 7:** Which of the two assemblies has the better BUSCO score? Why do you think this is?

**Question 8:** Which of the two assemblies has the better N50? Why do you think this is?



